package inmemory

import (
	"hash/fnv"
	"strconv"
	"sync"
)

type (
	// shard представляет отдельный сегмент кэша с собственной блокировкой.
	// Использует мьютекс для обеспечения потокобезопасной операций с данными.
	// Data хранит маппинг ID баннера на значение счетчика.
	shard struct {
		Mu   sync.Mutex
		Data map[int]int64

		// False sharing (ложное разделение) — это явление, при котором разные потоки обращаются к разным переменным,
		// Но эти переменные лежат рядом в памяти и попадают в одну кэш-линию процессора.
		// https://youtu.be/TjzeCWaTOtM
		_ [56]byte // padding чтобы избежать false sharing (64 байта на кэш линию)
	}

	// Cache реализует шардированный in-memory кэш для высокопроизводительного хранения счетчиков.
	// Использует множественные шарды для минимизации конкуренции между горутинами.
	// Распределение по шардам происходит на основе хэша ID баннера.
	Cache struct {
		Shards []*shard
	}
)

// Новый экземпляр Cache с указанным количеством шардов.
// Большее количество шардов уменьшает конкуренцию, но увеличивает накладные расходы.
// Рекомендуется использовать количество шардов равное количеству CPU ядер!.
func New(size int) *Cache {
	shards := make([]*shard, size)
	for i := range shards {
		shards[i] = &shard{Data: make(map[int]int64)}
	}
	return &Cache{shards}
}

// Возвращает шард для указанного ID баннера на основе хэш-функции.
// Использует FNV-1a хэш для равномерного распределения данных по шардам.
// Гарантирует, что один и тот же ID всегда попадет в один и тот же шард.
func (c *Cache) GetShard(id int) *shard {
	h := fnv.New32a()
	h.Write([]byte(strconv.Itoa(id)))

	return c.Shards[uint(h.Sum32())%uint(len(c.Shards))]
}
